{"version":3,"names":[],"mappings":"","sources":["rtc.js"],"sourcesContent":["// Coordinates your peers. Sets up connections, streams, and channels.\n// Based on webrtc.io\n\nimport {Peer} from './peer';\n\nvar _ = require('lodash'),\n    io = require('socket.io');\n\nmodule.exports = (log, emitter, signaler) => {\n  if (!log) log = require('../log');\n  if (!emitter) emitter = require('../emitter')();\n  if (!signaler) signaler = require('./signaler')();\n\n  var signal;\n\n  var {emit: fire, on, off} = emitter();\n\n  return server => {\n    if (signal === undefined) signal = connectToSignal(server);\n\n    if (signal.ready) setTimeout(() => fire('ready', signal.myID), 0); // oof, get me (this line of code) out of here\n\n    return signal;\n  };\n\n  /*\n  +  Signalling\n  */\n  function connectToSignal(server) {\n    var signal = {\n      on: on,\n      off: off,\n      joinRoom: joinRoom,\n      leaveRoom: leaveRoom,\n      leaveRooms: leaveRooms,\n      adminRoom: adminRoom,\n      currentRooms: {},\n      close: close\n    };\n\n    var {currentRooms: rooms} = signal;\n\n    var peers = [],\n        peersHash = {};\n\n    var signalerEmitter = emitter();\n\n    var socket = io(server + '/signal');\n\n    var emit = (event, data) => socket.emit(event, data);\n    var socketSignaler = signaler({\n        emit: (name, data) => emit('peer ' + name, data),\n        on: signalerEmitter.on\n      });\n\n    socket.on('error', (...args) => log.error('Failed to connect socket.io', ...args));\n\n    // These are the messages we receive from the signal and their handlers\n    _.each({\n      'connect':      () => log.info('Connected to server'),\n      'your_id':    myID => gotID(myID),\n\n      'room':       data => updateRoom(data),\n\n      'peer join':  data => socketSignaler.managePeer(newPeer(data.id)),\n      'peer leave': data => socketSignaler.dropPeer(removePeerByID(data.id)), // What happens if id is non-existent?\n\n      'peer offer':      data => signalerEmitter.emit('offer', data),\n      'peer answer':     data => signalerEmitter.emit('answer', data),\n      'peer candidates': data => signalerEmitter.emit('candidates', data),\n\n      'broadcast ready': data => fire('broadcast_ready', socketSignaler.managePeer(newPeer(data.broadcasterID))), // think of better event names for this?\n      'broadcast error': data => fire('broadcast_error', data),\n\n      'error': error => log.error(error)\n    }, (handler, name) => socket.on(name, function() {\n      handler.apply(this, arguments);\n      fire(name, ...arguments); //broadcast ready and broadcast error will fire twice!\n    }));\n\n    function gotID(myID) {\n      log('Got ID', myID);\n\n      signal.myID = myID;\n\n      signal.ready = true;\n      fire('ready', myID);\n    }\n\n    function updateRoom(data) {\n      var room = rooms[data.roomName] || {};\n      _.extend(room, data); // can do better than this!\n      console.log('got room', room);\n      if (room.broadcasterID) socketSignaler.managePeer(newPeer(room.broadcasterID, {isExistingPeer: true}));\n      else _.each(data.peerIDs, peerID => socketSignaler.managePeer(newPeer(peerID, {isExistingPeer: true})));\n    }\n\n    function newPeer(id, config) {\n      config = config || {isExistingPeer: false};\n\n      var peer = new Peer(id, config);\n      peers.push(peer);\n      peersHash[id] = peer;\n\n      fire('peer add', peer);\n\n      return peer;\n    }\n\n    function removePeerByID(id) {\n      var peer = getPeer(id);\n      if (peer) {\n        peer.close();\n        _.remove(peers, peer => { return peer.id === id; });\n        delete peersHash[id];\n        fire('peer remove', peer);\n        return peer;\n      }\n    }\n\n    function joinRoom(roomName) {\n      rooms[roomName] = rooms[roomName] || {roomName: roomName};\n      emit('room join', roomName);\n      fire('room join', roomName);\n    }\n\n    function leaveRoom(roomName) {\n      delete rooms[roomName];\n\n      emit('room leave', roomName);\n      fire('room leave', roomName);\n    }\n\n    function leaveRooms() {\n      for (var i = rooms.length -1; i >= 0; i--) leaveRoom(rooms[i]);\n    }\n\n    function adminRoom(roomName, command) {\n      log('admining', roomName, command);\n      emit('room admin', _.extend({roomName}, command));\n      //Should we check for responses or something?\n    }\n\n    function close() {\n      socket.close();\n      _.each(peers, peer => peer.close());\n      signal = undefined;\n    }\n\n    function getPeer(id) {\n      return peersHash[id];\n    }\n\n    return signal;\n  }\n  /*\n  -  Signalling\n  */\n};"],"file":"rtc.js","sourceRoot":"/source/"}