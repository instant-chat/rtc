{"version":3,"names":[],"mappings":"","sources":["peer.js"],"sourcesContent":["import {Channel} from './channel';\nimport {Stream} from './stream';\n\nvar _ = require('lodash'),\n    emitter = require('es-emitter')();\n\n\nvar RTCPeerConnection = (window.PeerConnection || window.webkitPeerConnection00 || window.webkitRTCPeerConnection || window.mozRTCPeerConnection);\nvar RTCSessionDescription = (window.mozRTCSessionDescription || window.RTCSessionDescription);\nvar RTCIceCandidate = (window.mozRTCIceCandidate || window.RTCIceCandidate);\n\nvar CONNECTION_EVENTS = ['negotiation_needed', 'ice_candidate', 'signaling_state_change',\n                         'add_stream', 'remove_stream', 'ice_connection_state_change',\n                         'data_channel'];\n\nvar iceServers = {\n  iceServers: [\n    {url: 'stun:104.131.128.101:3478', urls: 'stun:104.131.128.101:3478'},\n    {url: 'turn:104.131.128.101:3478', urls: 'turn:104.131.128.101:3478', username: 'turn', credential: 'turn'}\n  ],\n  iceTransports: 'all'\n};\n\nclass Peer {\n  constructor(id, config) {\n    this._id = id;\n    this._config = config;\n    this._remoteCandidates = [];\n    this._localCandidates = [];\n    this._remoteStreams = [];\n    this._localStreams = [];\n    this._channels = {};\n    this._events = {};\n\n    this._isConnectingPeer = false;\n    this._connectPromise = null;\n\n    this._connectCalled = false;\n    this._connected = false;\n\n    this._isReadyForIceCandidates = false;\n    this._iceCandidatePromises = [];\n\n    this._nextChannelID = 0;\n\n    this._log = [];\n\n    var connection = this._connection = new RTCPeerConnection(iceServers);\n\n    var {emit, on, off} = emitter({\n      attemptIntercept: (event, listener) => {\n        if (connection && CONNECTION_EVENTS.indexOf(event) != -1) {\n          connection.addEventListener(event.replace(/_/g, ''), listener);\n          return true;\n        }\n        return false;\n      }\n    });\n\n    this.fire = emit;\n    this.on = on;\n    this.off = off;\n\n    this.on({\n      'ice_candidate':  event => this._localCandidates.push(event.candidate),\n      'data_channel':   event => this._addChannel(event.channel),\n      'add_stream':     event => this._addRemoteStream(event.stream)\n    });\n\n    this.on({\n      'ice_connection_state_change': event => {\n        switch (connection.iceConnectionState) {\n          case 'connected':\n          case 'completed':\n            this._connected = true;\n            console.log('connected!');\n            break;\n          case 'failed':\n          case 'disconnected':\n          case 'closed':\n            this._connected = false;\n            this.fire('disconnected');\n        }\n      }\n    });\n  }\n\n  connect() {\n    this._isConnectingPeer = true;\n\n    this._connectPromise = this._connectPromise || new Promise((resolve, reject) => {\n      var connectWatcher = event => {\n        this._connectCalled = true;\n\n        var connection = event.target;\n\n        switch (connection.iceConnectionState) {\n          case 'connected':\n          case 'completed':\n            this._connected = true;\n            connection.removeEventListener('iceconnectionstatechange', connectWatcher);\n            resolve(this);\n            break;\n          case 'failed':\n          case 'disconnected':\n          case 'closed':\n            connection.removeEventListener('iceconnectionstatechange', connectWatcher);\n            reject({peer: this, event: event});\n            break;\n        }\n      };\n\n      this._connection.addEventListener('iceconnectionstatechange', connectWatcher);\n\n      this.initiateOffer()\n        .then(offer => this.fire('offer ready', offer))\n        .catch(error => this.fire('offer error'));\n    });\n\n    return this._connectPromise;\n  }\n\n  initiateOffer(options) {\n    options = options || {mandatory: {OfferToReceiveAudio: true, OfferToReceiveVideo: true}};\n    return new Promise((resolve, reject) => {\n      this._connection.createOffer(\n        offer =>\n          this._connection\n              .setLocalDescription(offer,\n                () => resolve(this._connection.localDescription),\n                error => reject('peer error set_local_description', this, error, offer)),\n        error => reject(error),\n        options);\n    });\n  }\n\n  receiveOffer(offer) {\n    return new Promise((resolve, reject) => {\n      this._connection.setRemoteDescription(new RTCSessionDescription(offer),\n        () => {\n          this._resolveIceCandidatePromises();\n          this._connection.createAnswer(\n            answer => {\n              this._connection.setLocalDescription(answer, () => resolve(this._connection.localDescription), error => reject('peer error set_local_description', this, error, answer));\n            },\n            error => reject('peer error send answer', this, error, offer));\n        },\n        error => reject('peer error set_remote_description', this, error, offer));\n    });\n  }\n\n  receiveAnswer(answer) {\n    return new Promise((resolve, reject) => this._connection.setRemoteDescription(new RTCSessionDescription(answer), () => {\n      this._resolveIceCandidatePromises();\n      resolve();\n    }, reject));\n  }\n\n  addIceCandidates(candidates) {\n    return new Promise((outerResolve, outerReject) => {\n      _.each(candidates, candidate => {\n        this._iceCandidatePromises.push(() => {\n          return new Promise((resolve, reject) => {\n            this._connection.addIceCandidate(new RTCIceCandidate(candidate), () => {\n              this._remoteCandidates.push(candidate);\n              resolve();\n            }, error => {\n              reject(error);\n            });\n          });\n        });\n      });\n\n      this._resolveIceCandidatePromises(outerResolve, outerReject);\n    });\n  }\n\n  addChannel(label, options, channelHandler) {\n    label = label || ('data-channel-' + this._nextChannelID++);\n    // options = options || {};\n    // options.negotiated = false;\n\n    var channel = this._addChannel(this._connection.createDataChannel(label, options), channelHandler);\n\n    return channel;\n  }\n\n  removeChannel(label) {\n    var channel = this._channels[label];\n    if (channel) {\n      delete this._channels[label];\n      this.fire('channel removed', channel);\n    }\n  }\n\n  addLocalStream(stream) {\n    var localStream = new Stream(this, stream);\n\n    this._localStreams.push(localStream);\n\n    this._addLocalStream(stream);\n\n    return localStream;\n  }\n\n  removeStream(stream) {\n    var index = this._localStreams.indexOf(stream);\n    if (index != 1) {\n      this._localStreams.splice(index, 1);\n      this._connection.removeStream(stream.stream);\n    }\n  }\n\n  forwardStream(stream) {\n    this._localStreams.push(stream);\n    this._addLocalStream(stream.stream);\n  }\n\n  close() {\n    if (this._connection && this._connection.iceConnectionState != 'closed') this._connection.close();\n  }\n\n  getStats() {\n    return new Promise((resolve, reject) => {\n      this._connection.getStats(resolve, reject);\n    });\n  }\n\n  get id() { return this._id; }\n  get config() { return this._config; }\n  get localStreams() { return this._localStreams; }\n  get remoteStreams() { return this._remoteStreams; }\n  get channels() { return this._channels; }\n  get isConnectingPeer() { return this._isConnectingPeer; }\n  get log() { return this._log; }\n\n  //channel(label) { return this._channels[label]; }\n\n  channel(label) {\n    var promises = this._channelPromises = this._channelPromises || {};\n\n    var promise = promises[label] = promises[label] || new Promise((resolve, reject) => {\n      var channel = this._channels[label];\n\n      if (channel) resolve(channel);\n      else {\n        var listener = channel => {\n          if (channel.label == label) {\n            this.off('channel add', listener);\n            resolve(channel);\n          }\n        };\n\n        this.on('channel add', listener);\n      }\n    });\n\n    return promise;\n  }\n\n  stream(id) { return _.find(this._remoteStreams, {'id': id}); }\n\n  // Do we want to expose this?!\n  get connection() { return this._connection; }\n\n  _addChannel(channel) {\n    channel = new Channel(this, channel);\n\n    channel.on({\n      'close': () => this.removeChannel(channel.label)\n    });\n\n    this._channels[channel.label] = channel;\n\n    this.fire('channel add', channel);\n\n    return channel;\n  }\n\n  _addLocalStream(stream) {\n    this._connection.addStream(stream);\n    console.log('_adding local stream');\n    // This might not be a good idea. What happens if\n    // _addLocalStream is called again before the offer is full resolved?\n    if (this._connected) {\n      this.initiateOffer()\n        .then(offer => this.fire('offer ready', offer))\n        .catch(error => {\n          console.log(error);\n          this.fire('offer error');\n        });\n    }\n    this.fire('localStream add', stream);\n    return stream;\n  }\n\n  _addRemoteStream(stream) {\n    console.log('add remote stream');\n    stream = new Stream(this, stream);\n    this._remoteStreams.push(stream);\n    this.fire('remoteStream add', stream);\n    return stream;\n  }\n\n  _resolveIceCandidatePromises(resolve, reject) {\n    if (this._connection.signalingState != 'have-local-offer' && this._connection.remoteDescription) {\n      Promise\n        .all(_.map(this._iceCandidatePromises, fn => {return fn();}))\n        .then(() => resolve())\n        .catch(reject);\n\n      this._iceCandidatePromises.splice(0);\n    }\n  }\n\n  _log() {\n    this._log.push({\n      at: new Date(),\n      args: [...arguments]\n    });\n  }\n}\n\nexport {Peer};"],"file":"peer.js","sourceRoot":"/source/"}